---
title: "reverse_modelling_analysis"
author: "Wenyu"
date: "5/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
fig_res  <- "~/cluster_wrk/drug_moa/sensitivity_fitting/fig_res"

```

```{r}
library(tidyverse)
library(tidymodels)
load("~/cluster_scratch/ctrp/ctrpv2_data.RData")

ces <- read_csv("~/cluster_scratch/impute_ess_20q4/ces1_478.csv")
ceres <- read_csv("~/cluster_scratch/impute_ess_20q4/ceres_478.csv")
demeter2 <- read_csv("~/cluster_scratch/impute_ess_20q4/demeter2_478.csv")
```


```{r}
ctrpv2_reverse_modeling <- ctrpv2_data %>% 
  mutate(reverse_modelling_data = map2(.x = sensitivity, .y = target,
                                       .f = function(x,y){
                                         tmp <- x %>% select(area_under_curve, DepMap_ID) 
                                         
                                         tmp1 <- ceres %>% 
                                           select(one_of(c("DepMap_ID",y$gene_symbol_of_protein_target))) %>% 
                                           rename_if(.predicate = !(names(.) %in% "DepMap_ID"),
                                                     .fun= ~paste0(.,"_ceres"))
                                         
                                         tmp2 <- demeter2 %>% 
                                           select(one_of(c("DepMap_ID",y$gene_symbol_of_protein_target))) %>% 
                                           rename_if(.predicate = !(names(.) %in% "DepMap_ID"),
                                                     .fun= ~paste0(.,"_demeter2"))
                                         tmp3 <- ces %>%
                                           select(one_of(c("DepMap_ID",y$gene_symbol_of_protein_target))) %>%
                                           rename_if(.predicate = !(names(.) %in% "DepMap_ID"),
                                                     .fun= ~paste0(.,"_ces"))

                                         
                                         tmp %>% 
                                           inner_join(tmp1, by="DepMap_ID") %>%
                                           inner_join(tmp2, by="DepMap_ID") %>%
                                           inner_join(tmp3, by="DepMap_ID") %>%
                                           select(-DepMap_ID) %>% 
                                           drop_na()
                                       }
  )
  )
```


```{r,eval=F}
ctrpv2_reverse_modeling <- ctrpv2_reverse_modeling %>% 
  ungroup() %>% 
  mutate(target_num= map_int(target, nrow)) %>% 
  # mutate(model_possibility= map_lgl(reverse_modelling_data, ~ncol(.x)>1)) %>% 
  mutate(target_ceres_avaliability = map_int(reverse_modelling_data, ~sum(str_count(string = colnames(.x), pattern= "_ceres")) )) %>% 
  mutate(target_demeter2_avaliability = map_int(reverse_modelling_data, ~sum(str_count(colnames(.x), pattern= "_demeter2")) )) %>%
  mutate(model_possibility = ((target_ceres_avaliability > 0) & (target_demeter2_avaliability > 0)))
# mutate(ceres_demeter2 = .data$target_ceres_avaliability - .data$target_demeter2_avaliability)  

# tmp <- ctrpv2_reverse_modeling %>% 
#   select(3,9:13) 

ctrpv2_reverse_modeling <- ctrpv2_reverse_modeling %>% 
  mutate(avaliable_obs= map_int(reverse_modelling_data, nrow))
```



```{r}
reverse_modeling_CV <- ctrpv2_reverse_modeling %>%
  select(master_cpd_id, reverse_modelling_data,  model_possibility) %>%
  filter(model_possibility) %>%
  select(-model_possibility) %>%
  mutate(cv_split =
           map(reverse_modelling_data, ~vfold_cv(.x, v = 5) ) ) %>%
  select(-reverse_modelling_data)


get_train_test <- 
  function(df){
    df <- df %>% 
      mutate(training_data = map(splits, ~analysis(.x))) %>% 
      mutate(testing_data = map(splits, ~assessment(.x))) 
  }


reverse_modeling_CV <-  reverse_modeling_CV %>%
  mutate(cv_split = map(cv_split, get_train_test))

# what is the difference between training&testing function and analysis&assessment function?
# I found no difference...
# tmp <- df %>% mutate(training_data = map(splits, ~training(.x)))
# tmp1 <- df %>% mutate(training_data = map(splits, ~analysis(.x)))
# identical(tmp, tmp1)
```

Now I have a deeply nested df:
in reverse_modeling_cv, each line is a drug, 
in the cv_split column, each element is a dataframe with 5 rows, 
each row corresponding to 5 fold training data and 5 fold testing data


I desiged a deep function to return a result df for each drug (15 rows for 3 matrics* 5 fold for three modeling strategy(3 columns)) 
```{r}


#note the further work is wrap the following steps(copied from my rnotebook2) as a function and map over all drugs


# for a given drug: I am going to first generate formular object to represent different model design for linear regression models
# since the data for a given drug is a df which has 

data = reverse_modeling_CV %>% filter(master_cpd_id== "687954") %>% pull(cv_split) 
data <- data[[1]]


tmp <- train_and_pred(df = data)



```


```{r}
# res_list <- vector("list", length = 358)
# for (i in 1:358){
#   # i=2
#   print(i)
#   data <- reverse_modeling_CV$cv_split[[i]]
#   # res_list[[i]] <- train_and_pred(data)
#   tryCatch(
#     # expr = res_list[[i]] <- train_and_pred(data),
#     expr =    res_list[[i]] <- train_and_pred(data),
#     error = function(e){ skip_to_next <<- TRUE}
#     )
#   if(skip_to_next) {
#     # messange= str_c(c("problem in",i),collapse = " ")
#     # print(message)
#     next } 
#   # else {res_list[[i]] <- train_and_pred(data)}
# }

#this analysis is moved to server to accelerate.
save.image("~/cluster_scratch/reverse_modelling/reverse_serverinput.RData")
# res_list <- vector("list", length = 354)
# for (i in 1:354){
#   # i=2
#   print(i)
#   data <- reverse_modeling_CV$cv_split[[i]]
#   res_list[[i]] <- train_and_pred(data)}
```

now I have list with each element being the df I mentioned earlier
Lets pull the result out so that it would be easier to check/compute the summary level statistics

```{r}
load("~/cluster_scratch/reverse_modelling/reverse_modelling_res.RData")
reverse_modeling_result <- reverse_modeling_CV %>% 
  mutate(res= res_list) %>% 
  mutate(res= map(res, .f = function(df){df %>% gather(key= "modeling_strategy", value= "score", ceres:ces)})) %>% 
  select(master_cpd_id,res)  
  # right_join(ctrpv2_compound, by= "master_cpd_id")

# df <- reverse_modeling_result$res[[1]]

# provide a function to generate the summary level statistic for given metric
# Is it possible to evaluate the value of the parameters input by users as a function object, and use that function object to do something? 
get_metric <- 
  function(df, metric, strategy, summary_statistics = "mean"){
    # method= vars(method)
    tmp <- df %>% 
      filter(.metric == !!metric) %>%
      filter(modeling_strategy == !!strategy) %>% 
      pull(score) 
  if (summary_statistics == "mean") tmp1 <- mean(tmp)
  if (summary_statistics == "median") tmp1 <- median(tmp)
  return(tmp1)
  }

# df= reverse_modeling_result %>% filter(master_cpd_id == 687954) %>% pull(res)
# df <- df[[1]]
# get_metric(df = df,metric = "rsq",strategy = "ces")

# note the null is problematic for processing in map function

reverse_modeling_result <- reverse_modeling_result %>% 
  mutate(ceres_rsq_mean = map_dbl(.x = res, .f = get_metric, metric = "rsq", strategy = "ceres" )) %>% 
  mutate(demeter_rsq_mean = map_dbl(.x = res, .f = get_metric, metric = "rsq", strategy = "demeter" )) %>% 
  mutate(ces_rsq_mean = map_dbl(.x = res, .f = get_metric, metric = "rsq", strategy = "ces" )) %>% 
  arrange(desc(ces_rsq_mean))
  

```


now  generate the images using the result
```{r, fig.width=4,fig.height=2.5}
tmp <- reverse_modeling_result %>% 
  select(-res, -master_cpd_id) 
  
  
colnames(tmp) <- c("CERES", "DEMETER2", "CES") 

fig  <- tmp %>% 
  pivot_longer(cols= 1:3, names_to = "Essentiality_score", values_to= "Rsq") %>% 
  ggplot(aes(x= Essentiality_score, y= Rsq))+
  geom_boxplot() +
  theme_classic() +
  coord_flip()+ 
  xlab("Essentiality scoring metric")+
  ylab(expression(R^2))

ggsave(fig, filename = "fig2b.pdf",path = fig_res,width = 4,height = 2.5,units = "in")  
```





check the performance
```{r}
# cor.test(reverse_modeling_result$ceres_rsq_mean, reverse_modeling_result$ces_rsq_mean)


# cor.test(reverse_modeling_result$ceres_rsq_mean, reverse_modeling_result$demeter_rsq_mean)
# t.test(x = (reverse_modeling_result$ces_rsq_mean), y = (reverse_modeling_result$ceres_rsq_mean), paired = T)

t.test(x = (reverse_modeling_result$ces_rsq_mean), y = (reverse_modeling_result$demeter_rsq_mean), paired = T)
t.test(x = (reverse_modeling_result$ces_rsq_mean), y = (reverse_modeling_result$ceres_rsq_mean), paired = T)

# performance on test set are highly correlated between the model with ceres and demeter. And there is no significant difference on the global scale, suggesting the variance of the performance among drugs may due to the quality of the drug target infomation
# on the other hand, combining ceres and demeter2 together did improve the performance. 

reverse_modeling_result <- reverse_modeling_result %>%  
    right_join(ctrpv2_compound, by= "master_cpd_id")
```

dabrafenib 687954 targeting braf

several other braf inhibitors seems all have quite good performance
```{r}
tmp <- inner_join(ctrpv2_data %>% select(-sensitivity),reverse_modeling_result %>% select(-res) ) %>% arrange(ces_rsq_mean)
```

```{r}
# braf <- read_csv("https://depmap.org/portal/partials/entity_summary/download?entity_id=2110&dep_enum_name=Avana&size_biom_enum_name=expression&color=mutation")

# braf <- ceres %>% select(one_of("DepMap_ID", "BRAF"))
braf <- ces %>% select(one_of("DepMap_ID", "BRAF"))
dabrafenib <- ctrpv2_data %>% filter(master_cpd_id== "687954") %>% pull(sensitivity) 
dabrafenib <- dabrafenib[[1]]

data <- inner_join(braf, dabrafenib)#,by=c("Depmap ID"="DepMap_ID")) 
colnames(data)[2] <- "braf"
```


```{r,fig.width=2.5,fig.height=2.5}
cor.test(data$braf, y = data$area_under_curve)#,method = "spearman")
fig  <- data %>% ggplot(aes(x= braf, y = area_under_curve/15)) +
  geom_point(size=0.2)+
  theme_classic()+
  xlab("BRAF inhibition effect (CES)")+
  ylab("Drug sensitivity (AUC)")+
  ggtitle("Dabrafenib cor  0.79")
fig
ggsave(fig, filename = "fig2c.pdf",path = fig_res,width = 2.5,height = 2.5,units = "in")  
```

628408 Repligen 136 	
inhibitor of HDAC3

```{r}

hdac3 <- ces %>% select(one_of("DepMap_ID", "BRAF"))
repligen_136 <- ctrpv2_data %>% filter(master_cpd_id== "628408") %>% pull(sensitivity) 
repligen_136 <- repligen_136[[1]]

data <- inner_join(hdac3, repligen_136)#,by=c("Depmap ID"="DepMap_ID")) 
colnames(data)[2] <- "hdac3"
```
```{r,fig.width=2.5,fig.height=2.5}
cor.test(data$hdac3, y = data$area_under_curve)#,method = "spearman")
fig  <- data %>% ggplot(aes(x= hdac3, y = area_under_curve/15)) +
  geom_point(size=0.2)+
  theme_classic()+
  xlab("HDAC3 inhibition effect (CES)")+
  ylab("Drug sensitivity (AUC)")+
  ggtitle("Repligen136 cor  0.05")
fig
ggsave(fig, filename = "fig2d.pdf",path = fig_res,width = 2.5,height = 2.5,units = "in")  
```
