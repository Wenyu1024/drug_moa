---
title: "reverse_modelling_analysis"
author: "Wenyu"
date: "5/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(tidymodels)
load("~/cluster_scratch/ctrp/ctrpv2_data.RData")

ces <- read_csv("~/cluster_scratch/impute_ess_20q4/ces1_478.csv")
ceres <- read_csv("~/cluster_scratch/impute_ess_20q4/ceres_478.csv")
demeter2 <- read_csv("~/cluster_scratch/impute_ess_20q4/demeter2_478.csv")
```


```{r}
ctrpv2_reverse_modeling <- ctrpv2_data %>% 
  mutate(reverse_modelling_data = map2(.x = sensitivity, .y = target,
                                       .f = function(x,y){
                                         tmp <- x %>% select(area_under_curve, DepMap_ID) 
                                         
                                         tmp1 <- ceres %>% 
                                           select(one_of(c("DepMap_ID",y$gene_symbol_of_protein_target))) %>% 
                                           rename_if(.predicate = !(names(.) %in% "DepMap_ID"),
                                                     .fun= ~paste0(.,"_ceres"))
                                         
                                         tmp2 <- demeter2 %>% 
                                           select(one_of(c("DepMap_ID",y$gene_symbol_of_protein_target))) %>% 
                                           rename_if(.predicate = !(names(.) %in% "DepMap_ID"),
                                                     .fun= ~paste0(.,"_demeter2"))
                                         tmp3 <- ces %>%
                                           select(one_of(c("DepMap_ID",y$gene_symbol_of_protein_target))) %>%
                                           rename_if(.predicate = !(names(.) %in% "DepMap_ID"),
                                                     .fun= ~paste0(.,"_ces"))

                                         
                                         tmp %>% 
                                           inner_join(tmp1, by="DepMap_ID") %>%
                                           inner_join(tmp2, by="DepMap_ID") %>%
                                           inner_join(tmp3, by="DepMap_ID") %>%
                                           select(-DepMap_ID) %>% 
                                           drop_na()
                                       }
  )
  )
```


```{r}
ctrpv2_reverse_modeling <- ctrpv2_reverse_modeling %>% 
  ungroup() %>% 
  mutate(target_num= map_int(target, nrow)) %>% 
  # mutate(model_possibility= map_lgl(reverse_modelling_data, ~ncol(.x)>1)) %>% 
  mutate(target_ceres_avaliability = map_int(reverse_modelling_data, ~sum(str_count(string = colnames(.x), pattern= "_ceres")) )) %>% 
  mutate(target_demeter2_avaliability = map_int(reverse_modelling_data, ~sum(str_count(colnames(.x), pattern= "_demeter2")) )) %>%
  mutate(model_possibility = ((target_ceres_avaliability > 0) & (target_demeter2_avaliability > 0)))
# mutate(ceres_demeter2 = .data$target_ceres_avaliability - .data$target_demeter2_avaliability)  

# tmp <- ctrpv2_reverse_modeling %>% 
#   select(3,9:13) 

ctrpv2_reverse_modeling <- ctrpv2_reverse_modeling %>% 
  mutate(avaliable_obs= map_int(reverse_modelling_data, nrow))
```



```{r}
reverse_modeling_CV <- ctrpv2_reverse_modeling %>%
  select(master_cpd_id, reverse_modelling_data,  model_possibility) %>%
  filter(model_possibility) %>%
  select(-model_possibility) %>%
  mutate(cv_split =
           map(reverse_modelling_data, ~vfold_cv(.x, v = 5) ) ) %>%
  select(-reverse_modelling_data)


get_train_test <- 
  function(df){
    df <- df %>% 
      mutate(training_data = map(splits, ~analysis(.x))) %>% 
      mutate(testing_data = map(splits, ~assessment(.x))) 
  }


reverse_modeling_CV <-  reverse_modeling_CV %>%
  mutate(cv_split = map(cv_split, get_train_test))

# what is the difference between training&testing function and analysis&assessment function?
# I found no difference...
# tmp <- df %>% mutate(training_data = map(splits, ~training(.x)))
# tmp1 <- df %>% mutate(training_data = map(splits, ~analysis(.x)))
# identical(tmp, tmp1)
```

Now I have a deeply nested df:
in reverse_modeling_cv, each line is a drug, 
in the cv_split column, each element is a dataframe with 5 rows, 
each row corresponding to 5 fold training data and 5 fold testing data


I desiged a deep function to return a result df for each drug (15 rows for 3 matrics* 5 fold for three modeling strategy(3 columns)) 
```{r}
lm_model <-
  linear_reg() %>%
  set_mode("regression") %>%
  set_engine("lm")

#note the further work is wrap the following steps(copied from my rnotebook2) as a function and map over all drugs


# for a given drug: I am going to first generate formular object to represent different model design for linear regression models
# since the data for a given drug is a df which has 

data = reverse_modeling_CV$cv_split[[1]]

train_and_pred <- function(df){
  ceres_columns <- str_subset(string = colnames(df$training_data[[1]]), pattern = "_ceres")
  demeter_columns <- str_subset(string = colnames(df$training_data[[1]]), pattern = "_demeter")
  # if (is_empty(ceres_columns) | is_empty(demeter_columns) )  next
  formula_ceres <- as.formula(str_c("area_under_curve ~ ", str_c(ceres_columns, collapse = " + "), collapse = " "))
  formula_demeter2 <- as.formula(str_c("area_under_curve ~ ", str_c(demeter_columns, collapse = " + "), collapse = " "))
  
  formula_all <- as.formula(area_under_curve ~ .)

  tmp <-   df %>% 
    mutate(fit_lm_ceres  = map(training_data, ~fit(lm_model, formula_ceres, data = .x))) %>% 
    mutate(fit_lm_demeter2  = map(training_data, ~fit(lm_model, formula_demeter2, data = .x))) %>% 
    mutate(fit_lm_both = map(training_data, ~fit(lm_model,  formula_all, data = .x))) %>% 
    mutate(model_pred_ceres = map2(fit_lm_ceres, testing_data, ~predict(.x, new_data = .y))) %>% 
    mutate(model_pred_demeter2 = map2(fit_lm_demeter2, testing_data, ~predict(.x, new_data = .y))) %>% 
    mutate(model_pred_both = map2(fit_lm_both, testing_data, ~predict(.x, new_data = .y))) %>% 
    mutate(res= pmap(list(testing_data, model_pred_ceres, model_pred_demeter2,model_pred_both),
                     function(first, second, third,fourth){
                       tibble(real = first$area_under_curve, 
                             pred_ceres=second$.pred,
                             pred_demeter2=third$.pred,
                             pred_both=fourth$.pred,                             
                             )}
                     )) 

get_perf <- function(x){
  x1= enquo(x)
  tmp %>% 
    select(id, res) %>% 
    unnest(res) %>% 
    group_by(id) %>% 
    metrics(truth = real, estimate = !!x1) %>% 
    ungroup() %>% 
    select(-3) 
}

perf_ceres <- get_perf("pred_ceres") %>% rename(ceres = .estimate)   
perf_demeter2 <- get_perf("pred_demeter2") %>% rename(demeter = .estimate)   
perf_both <- get_perf("pred_both") %>% rename(both = .estimate)   
 
  
res= perf_ceres %>% left_join(perf_demeter2,by = c("id", ".metric")) %>% left_join(perf_both,by = c("id", ".metric"))
return(res)
}


train_and_pred(df = data)



```


```{r}
res_list <- vector("list", length = 358)
for (i in 1:358){
  # i=2
  print(i)
  data <- reverse_modeling_CV$cv_split[[i]]
  # res_list[[i]] <- train_and_pred(data)
  tryCatch(
    # expr = res_list[[i]] <- train_and_pred(data),
    expr =    res_list[[i]] <- train_and_pred(data),
    error = function(e){ skip_to_next <<- TRUE}
    )
  if(skip_to_next) {
    # messange= str_c(c("problem in",i),collapse = " ")
    # print(message)
    next } 
  # else {res_list[[i]] <- train_and_pred(data)}
}
```

now I have list with each element being the df I mentioned earlier
Lets pull the result out so that it would be easier to check/compute the summary level statistics

```{r}
reverse_modeling_result <- reverse_modeling_CV %>% 
  mutate(res= res_list) %>% 
  mutate(res= map(res, .f = function(df){df %>% gather(key= "modeling_strategy", value= "score", ceres:both)})) %>% 
  select(master_cpd_id,res)  
  # right_join(ctrpv2_compound, by= "master_cpd_id")

df <- reverse_modeling_result$res[[1]]

# provide a function to generate the summary level statistic for given metric
# Is it possible to evaluate the value of the parameters input by users as a function object, and use that function object to do something? 
get_metric <- 
  function(df, metric, strategy, summary_statistics = "mean"){
    # method= vars(method)
    tmp <- df %>% 
      filter(.metric == !!metric) %>%
      filter(modeling_strategy == !!strategy) %>% 
      pull(score) 
  if (summary_statistics == "mean") tmp1 <- mean(tmp)
  if (summary_statistics == "median") tmp1 <- median(tmp)
  return(tmp1)
  }

get_metric(df = df,metric = "rsq",strategy = "both")

# note the null is problematic for processing in map function

reverse_modeling_result <- reverse_modeling_result %>% 
  # mutate(ind= map_lgl(reverse_modeling_result$res, is_null)) %>% 
  mutate(ceres_rsq_mean = map_dbl(.x = res, .f = get_metric, metric = "rsq", strategy = "ceres" )) %>% 
  mutate(demeter_rsq_mean = map_dbl(.x = res, .f = get_metric, metric = "rsq", strategy = "demeter" )) %>% 
  mutate(both_rsq_mean = map_dbl(.x = res, .f = get_metric, metric = "rsq", strategy = "both" ))
  # mutate_at(c("ceres_rsq", "demeter_rsq", "both_rsq"),.funs = unlist)
```

check the performance
```{r}
# cor.test(reverse_modeling_result$ceres_rsq_mean, reverse_modeling_result$both_rsq_mean)


cor.test(reverse_modeling_result$ceres_rsq_mean, reverse_modeling_result$demeter_rsq_mean)
t.test(x = (reverse_modeling_result$both_rsq_mean), y = (reverse_modeling_result$ceres_rsq_mean), paired = T)

t.test(x = (reverse_modeling_result$both_rsq_mean), y = (reverse_modeling_result$demeter_rsq_mean), paired = T)
t.test(x = (reverse_modeling_result$ceres_rsq_mean), y = (reverse_modeling_result$demeter_rsq_mean), paired = T)

# performance on test set are highly correlated between the model with ceres and demeter. And there is no significant difference on the global scale, suggesting the variance of the performance among drugs may due to the quality of the drug target infomation
# on the other hand, combining ceres and demeter2 together did improve the performance. 

reverse_modeling_result <- reverse_modeling_result %>%  
    right_join(ctrpv2_compound, by= "master_cpd_id")
```


